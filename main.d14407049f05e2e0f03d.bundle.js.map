{"version":3,"file":"main.d14407049f05e2e0f03d.bundle.js","sources":["webpack:///./src/intersection.ts"],"sourcesContent":["import invariant from 'invariant'\nimport { ObserverInstance, ObserverInstanceCallback } from './index'\n\nconst INSTANCE_MAP: Map<Element, ObserverInstance> = new Map()\nconst OBSERVER_MAP: Map<string, IntersectionObserver> = new Map()\nconst ROOT_IDS: Map<Element, string> = new Map()\n\nlet consecutiveRootId = 0\n\n/**\n * Generate a unique ID for the root element\n * @param root\n */\nfunction getRootId(root?: Element | null) {\n  if (!root) return ''\n  if (ROOT_IDS.has(root)) return ROOT_IDS.get(root)\n  consecutiveRootId += 1\n  ROOT_IDS.set(root, consecutiveRootId.toString())\n  return ROOT_IDS.get(root) + '_'\n}\n\n/**\n * Monitor element, and trigger callback when element becomes inView\n * @param element {HTMLElement}\n * @param callback {Function} Called with inView\n * @param options {Object} InterSection observer options\n * @param options.threshold {Number} Number between 0 and 1, indicating how much of the element should be inView before triggering\n * @param options.root {HTMLElement}\n * @param options.rootMargin {String} The CSS margin to apply to the root element.\n */\nexport function observe(\n  element: Element,\n  callback: ObserverInstanceCallback,\n  options: IntersectionObserverInit = {},\n) {\n  // IntersectionObserver needs a threshold to trigger, so set it to 0 if it's not defined.\n  // Modify the options object, since it's used in the onChange handler.\n  if (!options.threshold) options.threshold = 0\n  const { root, rootMargin, threshold } = options\n  // Validate that the element is not being used in another <Observer />\n  invariant(\n    !INSTANCE_MAP.has(element),\n    \"react-intersection-observer: Trying to observe %s, but it's already being observed by another instance.\\nMake sure the `ref` is only used by a single <Observer /> instance.\\n\\n%s\",\n    element,\n  )\n  /* istanbul ignore if */\n  if (!element) return\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  // An observer with the same options can be reused, so lets use this fact\n  let observerId: string =\n    getRootId(root) +\n    (rootMargin\n      ? `${threshold.toString()}_${rootMargin}`\n      : threshold.toString())\n\n  let observerInstance = OBSERVER_MAP.get(observerId)\n  if (!observerInstance) {\n    observerInstance = new IntersectionObserver(onChange, options)\n    /* istanbul ignore else  */\n    if (observerId) OBSERVER_MAP.set(observerId, observerInstance)\n  }\n\n  const instance: ObserverInstance = {\n    callback,\n    element,\n    inView: false,\n    observerId,\n    observer: observerInstance,\n    // Make sure we have the thresholds value. It's undefined on a browser like Chrome 51.\n    thresholds:\n      observerInstance.thresholds ||\n      (Array.isArray(threshold) ? threshold : [threshold]),\n  }\n\n  INSTANCE_MAP.set(element, instance)\n  observerInstance.observe(element)\n\n  return instance\n}\n\n/**\n * Stop observing an element. If an element is removed from the DOM or otherwise destroyed,\n * make sure to call this method.\n * @param element {Element}\n */\nexport function unobserve(element: Element | null) {\n  if (!element) return\n  const instance = INSTANCE_MAP.get(element)\n\n  if (instance) {\n    const { observerId, observer } = instance\n    const { root } = observer\n\n    observer.unobserve(element)\n\n    // Check if we are still observing any elements with the same threshold.\n    let itemsLeft = false\n    // Check if we still have observers configured with the same root.\n    let rootObserved = false\n    /* istanbul ignore else  */\n    if (observerId) {\n      INSTANCE_MAP.forEach((item, key) => {\n        if (key !== element) {\n          if (item.observerId === observerId) {\n            itemsLeft = true\n            rootObserved = true\n          }\n          if (item.observer.root === root) {\n            rootObserved = true\n          }\n        }\n      })\n    }\n    if (!rootObserved && root) ROOT_IDS.delete(root)\n    if (observer && !itemsLeft) {\n      // No more elements to observe for threshold, disconnect observer\n      observer.disconnect()\n    }\n\n    // Remove reference to element\n    INSTANCE_MAP.delete(element)\n  }\n}\n\n/**\n * Destroy all IntersectionObservers currently connected\n **/\nexport function destroy() {\n  OBSERVER_MAP.forEach(observer => {\n    observer.disconnect()\n  })\n\n  OBSERVER_MAP.clear()\n  INSTANCE_MAP.clear()\n  ROOT_IDS.clear()\n  consecutiveRootId = 0\n}\n\nfunction onChange(changes: IntersectionObserverEntry[]) {\n  changes.forEach(intersection => {\n    const { isIntersecting, intersectionRatio, target } = intersection\n    const instance = INSTANCE_MAP.get(target)\n\n    // Firefox can report a negative intersectionRatio when scrolling.\n    /* istanbul ignore else */\n    if (instance && intersectionRatio >= 0) {\n      // If threshold is an array, check if any of them intersects. This just triggers the onChange event multiple times.\n      let inView = instance.thresholds.some(threshold => {\n        return instance.inView\n          ? intersectionRatio > threshold\n          : intersectionRatio >= threshold\n      })\n\n      if (isIntersecting !== undefined) {\n        // If isIntersecting is defined, ensure that the element is actually intersecting.\n        // Otherwise it reports a threshold of 0\n        inView = inView && isIntersecting\n      }\n\n      instance.inView = inView\n      instance.callback(inView, intersection)\n    }\n  })\n}\n\nexport default {\n  observe,\n  unobserve,\n  destroy,\n}\n"],"mappings":"AAGA","sourceRoot":""}